<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FlexAnon - Test Integration</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 500px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 28px;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }

        .wallet-info {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .wallet-info.active {
            display: block;
        }

        .wallet-address {
            font-family: monospace;
            font-size: 12px;
            color: #555;
            word-break: break-all;
            margin-top: 5px;
        }

        #subscriptionBadge {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 12px 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            text-align: center;
            display: none;
            font-size: 14px;
        }

        .upgrade-btn {
            background: #ffd700;
            color: #333;
            padding: 5px 15px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
            font-weight: 600;
            font-size: 12px;
        }

        .upgrade-btn:hover {
            background: #ffed4e;
            transform: scale(1.05);
        }

        .status {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .status.active {
            display: block;
        }

        .status.info {
            background: #e3f2fd;
            color: #1976d2;
        }

        .status.success {
            background: #e8f5e9;
            color: #388e3c;
        }

        .status.error {
            background: #ffebee;
            color: #c62828;
        }

        button {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #connectBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        #connectBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        #generateBtn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            display: none;
        }

        #generateBtn.active {
            display: block;
        }

        #generateBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }

        .share-link {
            background: #f5f5f5;
            padding: 15px;
            border-radius: 10px;
            margin-top: 20px;
            display: none;
        }

        .share-link.active {
            display: block;
        }

        .share-url {
            font-family: monospace;
            font-size: 12px;
            color: #555;
            word-break: break-all;
            background: white;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }

        .copy-btn {
            background: #4caf50;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            width: auto;
            margin: 0;
        }

        .copy-btn:hover {
            background: #45a049;
        }

        .loader {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .footer {
            text-align: center;
            margin-top: 20px;
            color: #999;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>FlexAnon</h1>
        <p class="subtitle">Privacy-first portfolio sharing</p>

        <div id="walletInfo" class="wallet-info">
            <strong>Connected Wallet:</strong>
            <div class="wallet-address" id="walletAddress"></div>
        </div>

        <div id="subscriptionBadge"></div>

        <div id="status" class="status"></div>

        <button id="connectBtn">Connect Wallet</button>
        <button id="generateBtn">Generate Share Link</button>

        <div id="shareLink" class="share-link">
            <strong>Your Share Link:</strong>
            <div class="share-url" id="shareUrl"></div>
            <button class="copy-btn" onclick="copyLink()">Copy Link</button>
            <button class="copy-btn" onclick="refreshPortfolio()" style="background: #667eea; margin-left: 10px;">
                ðŸ”„ Refresh Portfolio
            </button>
        </div>

        <div class="footer">
            Devnet Testing | Privacy Preserved via Relayer
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script>
        const API_BASE = 'http://localhost:3001/api';
        let wallet = null;
        let walletAddress = null;
        let subscriptionStatus = null;

        const connectBtn = document.getElementById('connectBtn');
        const generateBtn = document.getElementById('generateBtn');
        const walletInfo = document.getElementById('walletInfo');
        const status = document.getElementById('status');
        const shareLink = document.getElementById('shareLink');

        // Base58 encoding function
        const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
        
        function base58Encode(buffer) {
            const bytes = new Uint8Array(buffer);
            const digits = [0];
            
            for (let i = 0; i < bytes.length; i++) {
                let carry = bytes[i];
                for (let j = 0; j < digits.length; j++) {
                    carry += digits[j] << 8;
                    digits[j] = carry % 58;
                    carry = (carry / 58) | 0;
                }
                
                while (carry > 0) {
                    digits.push(carry % 58);
                    carry = (carry / 58) | 0;
                }
            }
            
            for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
                digits.push(0);
            }
            
            return digits.reverse().map(d => BASE58_ALPHABET[d]).join('');
        }

        // SHA256 hash helper
        function sha256(data) {
            return CryptoJS.SHA256(data).toString(CryptoJS.enc.Hex);
        }

        // Create leaf key (hash of identifier)
        function createLeafKey(identifier) {
            return sha256(identifier);
        }

        // Create leaf value (hash of data)
        function createLeafValue(data) {
            const dataString = typeof data === 'string' ? data : JSON.stringify(data);
            return sha256(dataString);
        }

        // Build portfolio leaves using EXACT backend logic
        function buildPortfolioLeaves(portfolio, walletAddress) {
            const leaves = [];
            
            // 1. Wallet address
            leaves.push({
                key: createLeafKey('wallet_address'),
                value: createLeafValue(walletAddress.toLowerCase())
            });
            
            // 2. Chain
            leaves.push({
                key: createLeafKey('chain'),
                value: createLeafValue(portfolio.chain)
            });
            
            // 3. Total value
            leaves.push({
                key: createLeafKey('total_value'),
                value: createLeafValue(portfolio.total_value.toString())
            });
            
            // 4. PnL percentage
            leaves.push({
                key: createLeafKey('pnl_percentage'),
                value: createLeafValue(portfolio.pnl_percentage.toString())
            });
            
            // 5. Snapshot timestamp
            leaves.push({
                key: createLeafKey('snapshot_timestamp'),
                value: createLeafValue(portfolio.snapshot_timestamp.toString())
            });
            
            // 6. Total assets count
            leaves.push({
                key: createLeafKey('total_assets_count'),
                value: createLeafValue(portfolio.assets.length.toString())
            });
            
            // 7. Individual assets
            portfolio.assets.forEach((asset, index) => {
                const assetData = {
                    symbol: asset.symbol,
                    name: asset.name,
                    quantity: asset.quantity,
                    price: asset.price,
                    value: asset.value,
                    icon_url: asset.icon_url
                };
                
                leaves.push({
                    key: createLeafKey(`asset_${index}_${asset.symbol}`),
                    value: createLeafValue(JSON.stringify(assetData))
                });
            });
            
            return leaves;
        }

        // Simplified Sparse Merkle Tree implementation
        function buildSparseMerkleTree(leaves) {
            const EMPTY_HASH = sha256('EMPTY_LEAF');
            const TREE_DEPTH = 256;
            
            // Create leaf hashes
            const leafLevel = new Map();
            leaves.forEach(leaf => {
                const leafHash = sha256(leaf.key + ':' + leaf.value);
                leafLevel.set(leaf.key, leafHash);
            });
            
            // Build tree level by level
            let currentLevel = leafLevel;
            
            for (let depth = TREE_DEPTH - 1; depth >= 0; depth--) {
                const nextLevel = new Map();
                const processedParents = new Set();
                
                currentLevel.forEach((hash, bitPath) => {
                    if (bitPath.length === 0) return;
                    
                    const parentPath = bitPath.slice(0, -1);
                    if (processedParents.has(parentPath)) return;
                    
                    processedParents.add(parentPath);
                    
                    const leftPath = parentPath + '0';
                    const rightPath = parentPath + '1';
                    const leftChild = currentLevel.get(leftPath) || EMPTY_HASH;
                    const rightChild = currentLevel.get(rightPath) || EMPTY_HASH;
                    const parentHash = sha256(leftChild + rightChild);
                    
                    nextLevel.set(parentPath, parentHash);
                });
                
                currentLevel = nextLevel;
            }
            
            return currentLevel.get('') || EMPTY_HASH;
        }

        // Connect Wallet
        connectBtn.addEventListener('click', async () => {
            try {
                showStatus('Connecting to Phantom wallet...', 'info');
                
                if (!window.solana || !window.solana.isPhantom) {
                    showStatus('Phantom wallet not found! Please install Phantom.', 'error');
                    return;
                }

                const resp = await window.solana.connect();
                walletAddress = resp.publicKey.toString();
                wallet = window.solana;

                // Fetch subscription status
                await fetchSubscriptionStatus();

                document.getElementById('walletAddress').textContent = walletAddress;
                walletInfo.classList.add('active');
                generateBtn.classList.add('active');
                connectBtn.textContent = 'Connected';
                connectBtn.disabled = true;

                showStatus('Wallet connected successfully!', 'success');
                setTimeout(() => hideStatus(), 2000);

            } catch (err) {
                console.error('Wallet connection error:', err);
                showStatus('Failed to connect wallet: ' + err.message, 'error');
            }
        });

        // Fetch subscription status
        async function fetchSubscriptionStatus() {
            try {
                const response = await fetch(`${API_BASE}/subscription/status?wallet=${walletAddress}`);
                const data = await response.json();
                subscriptionStatus = data;
                
                // Update UI
                updateSubscriptionUI();
            } catch (error) {
                console.error('Error fetching subscription:', error);
            }
        }

        // Update subscription UI
        function updateSubscriptionUI() {
            if (!subscriptionStatus) return;
            
            const badge = document.getElementById('subscriptionBadge');
            const plan = subscriptionStatus.plan === 'pro' ? 'Pro ðŸ’Ž' : 'Free';
            const remaining = subscriptionStatus.updates_remaining;
            const limit = subscriptionStatus.updates_limit;
            
            badge.innerHTML = `
                <strong>${plan}</strong> | Updates: ${remaining}/${limit}
                ${subscriptionStatus.plan === 'free' && remaining < 5 ? 
                    '<button class="upgrade-btn" onclick="upgradeToPro()">âš¡ Upgrade to Pro</button>' : ''}
            `;
            badge.style.display = 'block';
        }

        // Upgrade to Pro (demo)
        async function upgradeToPro() {
            try {
                const response = await fetch(`${API_BASE}/subscription/upgrade-demo`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ wallet_address: walletAddress })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    showStatus('ðŸŽ‰ Upgraded to Pro! 1000 updates/month', 'success');
                    await fetchSubscriptionStatus();
                }
            } catch (error) {
                console.error('Upgrade error:', error);
                showStatus('Failed to upgrade', 'error');
            }
        }

        // Track update usage
        async function useUpdate() {
            if (!subscriptionStatus) return;
            
            try {
                await fetch(`${API_BASE}/subscription/use-update`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ wallet_address: walletAddress })
                });
                
                // Refresh subscription status
                await fetchSubscriptionStatus();
            } catch (error) {
                console.error('Failed to track update:', error);
            }
        }

        // Generate Share Link
        generateBtn.addEventListener('click', async () => {
            if (!walletAddress) {
                showStatus('Please connect wallet first', 'error');
                return;
            }

            try {
                generateBtn.disabled = true;
                generateBtn.innerHTML = 'Generating... <div class="loader"></div>';
                
                // Step 1: Fetch portfolio
                showStatus('Step 1/4: Fetching portfolio data...', 'info');
                
                const portfolioResponse = await fetch(`${API_BASE}/dev/test-zerion`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ wallet_address: walletAddress })
                });

                const portfolioData = await portfolioResponse.json();
                
                if (!portfolioData.success || !portfolioData.portfolio) {
                    throw new Error('Failed to fetch portfolio data');
                }

                const portfolio = portfolioData.portfolio;
                console.log('Portfolio:', portfolio);

                if (portfolio.assets.length === 0) {
                    throw new Error('Oops! Looks like your wallet doesn\'t have any mainnet balance!');
                }

                // Step 2: Build merkle leaves with EXACT backend logic
                showStatus('Step 2/4: Building merkle tree...', 'info');
                
                const leaves = buildPortfolioLeaves(portfolio, walletAddress);
                console.log('Leaves count:', leaves.length);
                console.log('First leaf:', leaves[0]);

                // Step 3: Calculate merkle root using SMT
                const merkleRootHex = buildSparseMerkleTree(leaves);
                console.log('Merkle Root:', merkleRootHex);

                // Convert hex to byte array for relayer
                const merkleRoot = [];
                for (let i = 0; i < merkleRootHex.length; i += 2) {
                    merkleRoot.push(parseInt(merkleRootHex.substr(i, 2), 16));
                }

                // Step 4: Sign and submit
                const timestamp = Date.now();
                const message = `FlexAnon Commitment

Wallet: ${walletAddress}
Merkle Root: ${merkleRootHex.substring(0, 32)}...
Timestamp: ${timestamp}

I authorize this commitment to be submitted via the FlexAnon relayer service.`;

                showStatus('Step 3/4: Signing and submitting via relayer...', 'info');

                const encodedMessage = new TextEncoder().encode(message);
                const signedMessage = await wallet.signMessage(encodedMessage, 'utf8');
                const signature = base58Encode(signedMessage.signature);

                const relayResponse = await fetch(`${API_BASE}/relayer/commit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        wallet_address: walletAddress,
                        merkle_root: merkleRoot,
                        metadata: {
                            chain: 'solana',
                            snapshot_timestamp: timestamp,
                            expires_at: null,
                            privacy_score: 75
                        },
                        signature: signature,
                        message: message,
                        timestamp: timestamp
                    })
                });

                const relayData = await relayResponse.json();

                if (!relayData.success) {
                    throw new Error(relayData.details || relayData.error || 'Relayer commit failed');
                }

                const commitmentAddress = relayData.commitment_address;
                const commitmentVersion = relayData.commitment_version;

                showStatus('Step 4/4: Generating share link...', 'info');

                const linkMessage = `FlexAnon Ownership Verification

I am the owner of wallet: ${walletAddress}

Timestamp: ${timestamp}

This signature proves I own this wallet and authorize share link generation.`;

                const linkEncodedMessage = new TextEncoder().encode(linkMessage);
                const linkSignedMessage = await wallet.signMessage(linkEncodedMessage, 'utf8');
                const linkSignature = base58Encode(linkSignedMessage.signature);

                const generateResponse = await fetch(`${API_BASE}/share/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        wallet_address: walletAddress,
                        signature: linkSignature,
                        message: linkMessage,
                        timestamp: timestamp,
                        commitment_address: commitmentAddress,
                        commitment_version: commitmentVersion,
                        chain: 'solana',
                        reveal_preferences: {
                            show_total_value: true,
                            show_pnl: true,
                            show_top_assets: true,
                            top_assets_count: 5,
                            show_wallet_address: false
                        }
                    })
                });

                const generateData = await generateResponse.json();

                if (!generateData.success) {
                    const errorMessage = generateData.user_friendly_message || 
                                       generateData.details || 
                                       generateData.error || 
                                       'Link generation failed';
                    throw new Error(errorMessage);
                }

                // Track update usage
                await useUpdate();

                // Show share link
                document.getElementById('shareUrl').textContent = generateData.share_url;
                shareLink.classList.add('active');
                showStatus('Share link generated successfully!', 'success');

                generateBtn.innerHTML = 'Generate Another Link';
                generateBtn.disabled = false;

            } catch (err) {
                console.error('Generation error:', err);
                showStatus('Failed: ' + err.message, 'error');
                generateBtn.innerHTML = 'Generate Share Link';
                generateBtn.disabled = false;
            }
        });

        function showStatus(message, type) {
            status.textContent = message;
            status.className = 'status active ' + type;
        }

        function hideStatus() {
            status.className = 'status';
        }

        function copyLink() {
            const url = document.getElementById('shareUrl').textContent;
            navigator.clipboard.writeText(url);
            showStatus('Link copied to clipboard!', 'success');
            setTimeout(() => hideStatus(), 2000);
        }

        async function refreshPortfolio() {
            if (!walletAddress) {
                showStatus('Please connect wallet first', 'error');
                return;
            }

            try {
                showStatus('Refreshing portfolio...', 'info');

                // Same flow as generating a link, but updates existing one
                // For hackathon demo, this just generates a new link
                // In production, this would update the existing commitment
                
                const portfolioResponse = await fetch(`${API_BASE}/dev/test-zerion`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ wallet_address: walletAddress })
                });

                const portfolioData = await portfolioResponse.json();
                
                if (!portfolioData.success || !portfolioData.portfolio) {
                    throw new Error('Failed to fetch portfolio data');
                }

                const portfolio = portfolioData.portfolio;

                if (portfolio.assets.length === 0) {
                    throw new Error('No assets found in portfolio');
                }

                // Build merkle tree
                const leaves = buildPortfolioLeaves(portfolio, walletAddress);
                const merkleRootHex = buildSparseMerkleTree(leaves);
                const merkleRoot = [];
                for (let i = 0; i < merkleRootHex.length; i += 2) {
                    merkleRoot.push(parseInt(merkleRootHex.substr(i, 2), 16));
                }

                // Sign and commit
                const timestamp = Date.now();
                const message = `FlexAnon Commitment

Wallet: ${walletAddress}
Merkle Root: ${merkleRootHex.substring(0, 32)}...
Timestamp: ${timestamp}

I authorize this commitment to be submitted via the FlexAnon relayer service.`;

                const encodedMessage = new TextEncoder().encode(message);
                const signedMessage = await wallet.signMessage(encodedMessage, 'utf8');
                const signature = base58Encode(signedMessage.signature);

                const relayResponse = await fetch(`${API_BASE}/relayer/commit`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        wallet_address: walletAddress,
                        merkle_root: merkleRoot,
                        metadata: {
                            chain: 'solana',
                            snapshot_timestamp: timestamp,
                            expires_at: null,
                            privacy_score: 75
                        },
                        signature: signature,
                        message: message,
                        timestamp: timestamp
                    })
                });

                const relayData = await relayResponse.json();

                if (!relayData.success) {
                    throw new Error(relayData.details || relayData.error || 'Relayer commit failed');
                }

                // Track update usage
                await useUpdate();

                showStatus('âœ… Portfolio refreshed! Link updated with latest data.', 'success');
                
            } catch (err) {
                console.error('Refresh error:', err);
                showStatus('Failed to refresh: ' + err.message, 'error');
            }
        }

        // Check for Phantom on load
        window.addEventListener('load', () => {
            if (!window.solana) {
                showStatus('Phantom wallet not detected. Please install Phantom browser extension.', 'error');
            }
        });
    </script>
</body>
</html>
